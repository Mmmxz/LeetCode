// 995. K 连续位的最小翻转次数
// 在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。

// 返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。

 

// 示例 1：

// 输入：A = [0,1,0], K = 1
// 输出：2
// 解释：先翻转 A[0]，然后翻转 A[2]。
// 示例 2：

// 输入：A = [1,1,0], K = 2
// 输出：-1
// 解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
// 示例 3：

// 输入：A = [0,0,0,1,0,1,1,0], K = 3
// 输出：3
// 解释：
// 翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
// 翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
// 翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
 

// 提示：

// 1 <= A.length <= 30000
// 1 <= K <= A.length

/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
// 解法 1 ：滑动窗口 暴力 时间复杂度较高
var minKBitFlips = function(A, K) {
  let left = 0, right = 0, count = 0
  while (right < A.length) {
    right++
    // 什么时候出元素？窗口大于 k 时
    if (right - left > K) {
      left++
    }
    // 什么时候翻转操作？窗口等于 k 时，并且窗口第一位是 0 才翻转。因为如果 1 也翻转了，窗口滑过后就无法改变窗口第一位的值了
    if (right - left === K && A[left] === 0) {
      // 翻转窗口，计数 +1
      count++
      for (let i = left; i < right; i++) {
        // A[i] = A[i] ? 0 : 1 // 9200ms+
        // A[i] = 1 - A[i] // 2500ms+
        A[i] ^= 1 // 1800ms+
      }
    }
  }
  // 如果此时数组中有 0 ，返回 -1 ，否则返回 count
  if (A.some(item => item === 0)) {
    return -1
  } else {
    return count
  }
};